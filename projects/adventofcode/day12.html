<!DOCTYPE html>
<html lang="en">

<head>
    <link rel="stylesheet" href="/site.css" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <meta charset="utf-8" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <title></title>
    
</head>

<body>
    <main>
        <header>
            <h1>Callista Krebs</h1>
            <p>
                <a href="/">Home</a>
                <a href="/projects">Projects</a>
                <a href="/contact.html">Contact</a>
            </p>
        </header>
        <article>
<!-- Must be unindented to prevent code indentation being broken -->
<h1 id="advent-of-code---day-12">Advent of Code - Day 12</h1>
<p><a href="day11.html">&lt; Prev Day</a> <a href="day13.html">Next Day
&gt;</a></p>
<h2 id="part-1">Part 1</h2>
<h3 id="my-code">My Code</h3>
<div class="sourceCode" id="cb1"><pre
class="sourceCode numberSource python numberLines"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a>DIRECTIONS <span class="op">=</span> [</span>
<span id="cb1-2"><a href="#cb1-2"></a>    (<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>), <span class="co"># up</span></span>
<span id="cb1-3"><a href="#cb1-3"></a>    (<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>), <span class="co"># left</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>    (<span class="dv">1</span>,<span class="dv">0</span>),  <span class="co"># down</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>    (<span class="dv">0</span>,<span class="dv">1</span>),  <span class="co"># right</span></span>
<span id="cb1-6"><a href="#cb1-6"></a>]</span>
<span id="cb1-7"><a href="#cb1-7"></a></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="kw">def</span> get_cost(plots):</span>
<span id="cb1-9"><a href="#cb1-9"></a>    costs <span class="op">=</span> []</span>
<span id="cb1-10"><a href="#cb1-10"></a>    <span class="cf">for</span> plot <span class="kw">in</span> plots:</span>
<span id="cb1-11"><a href="#cb1-11"></a>        area <span class="op">=</span> <span class="bu">len</span>(plot[<span class="dv">1</span>])</span>
<span id="cb1-12"><a href="#cb1-12"></a>        perimeter <span class="op">=</span> plot[<span class="dv">2</span>]</span>
<span id="cb1-13"><a href="#cb1-13"></a>        costs.append(area <span class="op">*</span> perimeter)</span>
<span id="cb1-14"><a href="#cb1-14"></a>    </span>
<span id="cb1-15"><a href="#cb1-15"></a>    total_cost <span class="op">=</span> <span class="bu">sum</span>(costs)</span>
<span id="cb1-16"><a href="#cb1-16"></a></span>
<span id="cb1-17"><a href="#cb1-17"></a>    <span class="cf">return</span> total_cost</span>
<span id="cb1-18"><a href="#cb1-18"></a></span>
<span id="cb1-19"><a href="#cb1-19"></a><span class="kw">def</span> get_neighbors(garden, point, visited <span class="op">=</span> <span class="va">None</span>, current_plot <span class="op">=</span> <span class="va">None</span>, perimeter<span class="op">=</span><span class="dv">0</span>):</span>
<span id="cb1-20"><a href="#cb1-20"></a>    <span class="cf">if</span> visited <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb1-21"><a href="#cb1-21"></a>        visited <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb1-22"><a href="#cb1-22"></a></span>
<span id="cb1-23"><a href="#cb1-23"></a>    <span class="cf">if</span> current_plot <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb1-24"><a href="#cb1-24"></a>        current_plot <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb1-25"><a href="#cb1-25"></a></span>
<span id="cb1-26"><a href="#cb1-26"></a>    <span class="cf">if</span> point <span class="kw">in</span> visited:</span>
<span id="cb1-27"><a href="#cb1-27"></a>        <span class="cf">return</span> current_plot, perimeter</span>
<span id="cb1-28"><a href="#cb1-28"></a></span>
<span id="cb1-29"><a href="#cb1-29"></a>    visited.add(point)</span>
<span id="cb1-30"><a href="#cb1-30"></a>    current_plot.add(point)</span>
<span id="cb1-31"><a href="#cb1-31"></a></span>
<span id="cb1-32"><a href="#cb1-32"></a>    <span class="cf">for</span> dr,dc <span class="kw">in</span> DIRECTIONS:</span>
<span id="cb1-33"><a href="#cb1-33"></a>        nr, nc <span class="op">=</span> point[<span class="dv">0</span>] <span class="op">+</span> dr, point[<span class="dv">1</span>] <span class="op">+</span> dc</span>
<span id="cb1-34"><a href="#cb1-34"></a>        <span class="cf">if</span> <span class="dv">0</span> <span class="op">&lt;=</span> nr <span class="op">&lt;</span> <span class="bu">len</span>(garden) <span class="kw">and</span> <span class="dv">0</span> <span class="op">&lt;=</span> nc <span class="op">&lt;</span> <span class="bu">len</span>(garden[<span class="dv">0</span>]):</span>
<span id="cb1-35"><a href="#cb1-35"></a>            <span class="cf">if</span> garden[point[<span class="dv">0</span>]][point[<span class="dv">1</span>]] <span class="op">==</span> garden[nr][nc]:</span>
<span id="cb1-36"><a href="#cb1-36"></a>                _, perimeter <span class="op">=</span> get_neighbors(garden, (nr,nc), visited, current_plot, perimeter<span class="op">=</span>perimeter)</span>
<span id="cb1-37"><a href="#cb1-37"></a>            <span class="co"># If they dont match, this position is a boundary</span></span>
<span id="cb1-38"><a href="#cb1-38"></a>            <span class="cf">else</span>:</span>
<span id="cb1-39"><a href="#cb1-39"></a>                perimeter <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb1-40"><a href="#cb1-40"></a>        <span class="cf">else</span>:</span>
<span id="cb1-41"><a href="#cb1-41"></a>            perimeter <span class="op">+=</span><span class="dv">1</span></span>
<span id="cb1-42"><a href="#cb1-42"></a>    </span>
<span id="cb1-43"><a href="#cb1-43"></a>    <span class="cf">return</span> current_plot, perimeter</span>
<span id="cb1-44"><a href="#cb1-44"></a></span>
<span id="cb1-45"><a href="#cb1-45"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:</span>
<span id="cb1-46"><a href="#cb1-46"></a>    <span class="cf">with</span> <span class="bu">open</span>(<span class="st">&quot;day12.txt&quot;</span>) <span class="im">as</span> f:</span>
<span id="cb1-47"><a href="#cb1-47"></a>        garden <span class="op">=</span> f.read().split(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb1-48"><a href="#cb1-48"></a>    </span>
<span id="cb1-49"><a href="#cb1-49"></a>    nrows <span class="op">=</span> <span class="bu">len</span>(garden)</span>
<span id="cb1-50"><a href="#cb1-50"></a>    ncols <span class="op">=</span> <span class="bu">len</span>(garden[<span class="dv">0</span>])</span>
<span id="cb1-51"><a href="#cb1-51"></a></span>
<span id="cb1-52"><a href="#cb1-52"></a>    plots <span class="op">=</span> [] <span class="co"># values are (letter, points included in the plot), area is the length of the set</span></span>
<span id="cb1-53"><a href="#cb1-53"></a>    visited <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb1-54"><a href="#cb1-54"></a>    <span class="cf">for</span> row <span class="kw">in</span> <span class="bu">range</span>(nrows):</span>
<span id="cb1-55"><a href="#cb1-55"></a>        <span class="cf">for</span> col <span class="kw">in</span> <span class="bu">range</span>(ncols):</span>
<span id="cb1-56"><a href="#cb1-56"></a>            <span class="cf">if</span> (row,col) <span class="kw">not</span> <span class="kw">in</span> visited:</span>
<span id="cb1-57"><a href="#cb1-57"></a>                curr_letter <span class="op">=</span> garden[row][col]</span>
<span id="cb1-58"><a href="#cb1-58"></a>                places, p <span class="op">=</span> get_neighbors(garden, (row,col), visited<span class="op">=</span>visited)</span>
<span id="cb1-59"><a href="#cb1-59"></a>                plots.append((curr_letter, places, p))</span>
<span id="cb1-60"><a href="#cb1-60"></a></span>
<span id="cb1-61"><a href="#cb1-61"></a>    <span class="bu">print</span>(get_cost(plots))</span></code></pre></div>
<h3 id="chatgpts-improved-code">ChatGPT&#x2019;s Improved Code</h3>
<div class="sourceCode" id="cb2"><pre
class="sourceCode numberSource python numberLines"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a><span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb2-2"><a href="#cb2-2"></a></span>
<span id="cb2-3"><a href="#cb2-3"></a>DIRECTIONS <span class="op">=</span> [</span>
<span id="cb2-4"><a href="#cb2-4"></a>    (<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>),  <span class="co"># up</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>    (<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>),  <span class="co"># left</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>    (<span class="dv">1</span>, <span class="dv">0</span>),   <span class="co"># down</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>    (<span class="dv">0</span>, <span class="dv">1</span>),   <span class="co"># right</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>]</span>
<span id="cb2-9"><a href="#cb2-9"></a></span>
<span id="cb2-10"><a href="#cb2-10"></a><span class="kw">def</span> get_cost(plots):</span>
<span id="cb2-11"><a href="#cb2-11"></a>    <span class="cf">return</span> <span class="bu">sum</span>(<span class="bu">len</span>(points) <span class="op">*</span> perimeter <span class="cf">for</span> _, points, perimeter <span class="kw">in</span> plots)</span>
<span id="cb2-12"><a href="#cb2-12"></a></span>
<span id="cb2-13"><a href="#cb2-13"></a><span class="kw">def</span> get_neighbors(garden, start, visited):</span>
<span id="cb2-14"><a href="#cb2-14"></a>    queue <span class="op">=</span> deque([start])</span>
<span id="cb2-15"><a href="#cb2-15"></a>    current_plot <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb2-16"><a href="#cb2-16"></a>    perimeter <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-17"><a href="#cb2-17"></a>    letter <span class="op">=</span> garden[start[<span class="dv">0</span>]][start[<span class="dv">1</span>]]</span>
<span id="cb2-18"><a href="#cb2-18"></a></span>
<span id="cb2-19"><a href="#cb2-19"></a>    <span class="cf">while</span> queue:</span>
<span id="cb2-20"><a href="#cb2-20"></a>        r, c <span class="op">=</span> queue.popleft()</span>
<span id="cb2-21"><a href="#cb2-21"></a>        <span class="cf">if</span> (r, c) <span class="kw">in</span> visited:</span>
<span id="cb2-22"><a href="#cb2-22"></a>            <span class="cf">continue</span></span>
<span id="cb2-23"><a href="#cb2-23"></a></span>
<span id="cb2-24"><a href="#cb2-24"></a>        visited.add((r, c))</span>
<span id="cb2-25"><a href="#cb2-25"></a>        current_plot.add((r, c))</span>
<span id="cb2-26"><a href="#cb2-26"></a></span>
<span id="cb2-27"><a href="#cb2-27"></a>        <span class="cf">for</span> dr, dc <span class="kw">in</span> DIRECTIONS:</span>
<span id="cb2-28"><a href="#cb2-28"></a>            nr, nc <span class="op">=</span> r <span class="op">+</span> dr, c <span class="op">+</span> dc</span>
<span id="cb2-29"><a href="#cb2-29"></a>            <span class="cf">if</span> <span class="dv">0</span> <span class="op">&lt;=</span> nr <span class="op">&lt;</span> <span class="bu">len</span>(garden) <span class="kw">and</span> <span class="dv">0</span> <span class="op">&lt;=</span> nc <span class="op">&lt;</span> <span class="bu">len</span>(garden[<span class="dv">0</span>]):</span>
<span id="cb2-30"><a href="#cb2-30"></a>                <span class="cf">if</span> garden[nr][nc] <span class="op">==</span> letter:</span>
<span id="cb2-31"><a href="#cb2-31"></a>                    <span class="cf">if</span> (nr, nc) <span class="kw">not</span> <span class="kw">in</span> visited:</span>
<span id="cb2-32"><a href="#cb2-32"></a>                        queue.append((nr, nc))</span>
<span id="cb2-33"><a href="#cb2-33"></a>                <span class="cf">else</span>:</span>
<span id="cb2-34"><a href="#cb2-34"></a>                    perimeter <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb2-35"><a href="#cb2-35"></a>            <span class="cf">else</span>:</span>
<span id="cb2-36"><a href="#cb2-36"></a>                perimeter <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb2-37"><a href="#cb2-37"></a></span>
<span id="cb2-38"><a href="#cb2-38"></a>    <span class="cf">return</span> current_plot, perimeter</span>
<span id="cb2-39"><a href="#cb2-39"></a></span>
<span id="cb2-40"><a href="#cb2-40"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:</span>
<span id="cb2-41"><a href="#cb2-41"></a>    <span class="cf">try</span>:</span>
<span id="cb2-42"><a href="#cb2-42"></a>        <span class="cf">with</span> <span class="bu">open</span>(<span class="st">&quot;day12.txt&quot;</span>) <span class="im">as</span> f:</span>
<span id="cb2-43"><a href="#cb2-43"></a>            garden <span class="op">=</span> f.read().strip().split(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb2-44"><a href="#cb2-44"></a>    <span class="cf">except</span> <span class="pp">FileNotFoundError</span>:</span>
<span id="cb2-45"><a href="#cb2-45"></a>        <span class="bu">print</span>(<span class="st">&quot;Input file &#39;day12.txt&#39; not found.&quot;</span>)</span>
<span id="cb2-46"><a href="#cb2-46"></a>        exit(<span class="dv">1</span>)</span>
<span id="cb2-47"><a href="#cb2-47"></a></span>
<span id="cb2-48"><a href="#cb2-48"></a>    nrows, ncols <span class="op">=</span> <span class="bu">len</span>(garden), <span class="bu">len</span>(garden[<span class="dv">0</span>])</span>
<span id="cb2-49"><a href="#cb2-49"></a>    visited <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb2-50"><a href="#cb2-50"></a>    plots <span class="op">=</span> []</span>
<span id="cb2-51"><a href="#cb2-51"></a></span>
<span id="cb2-52"><a href="#cb2-52"></a>    <span class="cf">for</span> row <span class="kw">in</span> <span class="bu">range</span>(nrows):</span>
<span id="cb2-53"><a href="#cb2-53"></a>        <span class="cf">for</span> col <span class="kw">in</span> <span class="bu">range</span>(ncols):</span>
<span id="cb2-54"><a href="#cb2-54"></a>            <span class="cf">if</span> (row, col) <span class="kw">not</span> <span class="kw">in</span> visited:</span>
<span id="cb2-55"><a href="#cb2-55"></a>                plot, perimeter <span class="op">=</span> get_neighbors(garden, (row, col), visited)</span>
<span id="cb2-56"><a href="#cb2-56"></a>                plots.append((garden[row][col], plot, perimeter))</span>
<span id="cb2-57"><a href="#cb2-57"></a></span>
<span id="cb2-58"><a href="#cb2-58"></a>    <span class="bu">print</span>(get_cost(plots))</span></code></pre></div>
<h2 id="part-2">Part 2</h2>
<h3 id="my-code-1">My Code</h3>
<div class="sourceCode" id="cb3"><pre
class="sourceCode numberSource python numberLines"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a>DIRECTIONS <span class="op">=</span> [</span>
<span id="cb3-2"><a href="#cb3-2"></a>    (<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>), <span class="co"># up</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>    (<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>), <span class="co"># left</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>    (<span class="dv">1</span>,<span class="dv">0</span>),  <span class="co"># down</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>    (<span class="dv">0</span>,<span class="dv">1</span>),  <span class="co"># right</span></span>
<span id="cb3-6"><a href="#cb3-6"></a>]</span>
<span id="cb3-7"><a href="#cb3-7"></a></span>
<span id="cb3-8"><a href="#cb3-8"></a>DIAGONALS <span class="op">=</span> {</span>
<span id="cb3-9"><a href="#cb3-9"></a>    (<span class="op">-</span><span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>): <span class="st">&quot;up-left&quot;</span>, <span class="co"># up left</span></span>
<span id="cb3-10"><a href="#cb3-10"></a>    (<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>): <span class="st">&quot;up-right&quot;</span>, <span class="co"># up right</span></span>
<span id="cb3-11"><a href="#cb3-11"></a>    (<span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>): <span class="st">&quot;down-left&quot;</span>, <span class="co"># down left</span></span>
<span id="cb3-12"><a href="#cb3-12"></a>    (<span class="dv">1</span>, <span class="dv">1</span>):  <span class="st">&quot;down-right&quot;</span><span class="co"># down right</span></span>
<span id="cb3-13"><a href="#cb3-13"></a>}</span>
<span id="cb3-14"><a href="#cb3-14"></a></span>
<span id="cb3-15"><a href="#cb3-15"></a></span>
<span id="cb3-16"><a href="#cb3-16"></a><span class="kw">def</span> is_in_bounds(garden, r,c):</span>
<span id="cb3-17"><a href="#cb3-17"></a>    <span class="cf">return</span> <span class="dv">0</span> <span class="op">&lt;=</span> r <span class="op">&lt;</span> <span class="bu">len</span>(garden) <span class="kw">and</span> <span class="dv">0</span> <span class="op">&lt;=</span> c <span class="op">&lt;</span> <span class="bu">len</span>(garden[<span class="dv">0</span>])</span>
<span id="cb3-18"><a href="#cb3-18"></a></span>
<span id="cb3-19"><a href="#cb3-19"></a></span>
<span id="cb3-20"><a href="#cb3-20"></a><span class="kw">def</span> get_corners(plots):</span>
<span id="cb3-21"><a href="#cb3-21"></a>    new_plots <span class="op">=</span> []</span>
<span id="cb3-22"><a href="#cb3-22"></a>    <span class="cf">for</span> idx,plot <span class="kw">in</span> <span class="bu">enumerate</span>(plots):</span>
<span id="cb3-23"><a href="#cb3-23"></a>        corners <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb3-24"><a href="#cb3-24"></a>        <span class="cf">for</span> r,c <span class="kw">in</span> plot[<span class="st">&quot;locations&quot;</span>]:</span>
<span id="cb3-25"><a href="#cb3-25"></a>            fence_needed <span class="op">=</span> [<span class="va">False</span>, <span class="va">False</span>, <span class="va">False</span>, <span class="va">False</span>] <span class="co"># up, left, down, right</span></span>
<span id="cb3-26"><a href="#cb3-26"></a>            <span class="cf">for</span> idx,(dr, dc) <span class="kw">in</span> <span class="bu">enumerate</span>(DIRECTIONS):</span>
<span id="cb3-27"><a href="#cb3-27"></a>                nr, nc <span class="op">=</span> r <span class="op">+</span> dr, c <span class="op">+</span> dc</span>
<span id="cb3-28"><a href="#cb3-28"></a>                <span class="cf">if</span> (nr,nc) <span class="kw">not</span> <span class="kw">in</span> plot[<span class="st">&quot;locations&quot;</span>]:</span>
<span id="cb3-29"><a href="#cb3-29"></a>                    fence_needed[idx] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb3-30"><a href="#cb3-30"></a>            </span>
<span id="cb3-31"><a href="#cb3-31"></a>            corners <span class="op">+=</span> count_corners(fence_needed)</span>
<span id="cb3-32"><a href="#cb3-32"></a></span>
<span id="cb3-33"><a href="#cb3-33"></a>            <span class="cf">for</span> idx,(dr,dc) <span class="kw">in</span> <span class="bu">enumerate</span>(DIAGONALS):</span>
<span id="cb3-34"><a href="#cb3-34"></a>                nr, nc <span class="op">=</span> r <span class="op">+</span> dr, c <span class="op">+</span> dc</span>
<span id="cb3-35"><a href="#cb3-35"></a>                <span class="cf">if</span> (nr,nc) <span class="kw">not</span> <span class="kw">in</span> plot[<span class="st">&quot;locations&quot;</span>]:</span>
<span id="cb3-36"><a href="#cb3-36"></a>                    <span class="cf">if</span> DIAGONALS[(dr,dc)] <span class="op">==</span> <span class="st">&quot;up-left&quot;</span> <span class="kw">and</span> <span class="kw">not</span> fence_needed[<span class="dv">0</span>] <span class="kw">and</span> <span class="kw">not</span> fence_needed[<span class="dv">1</span>]:</span>
<span id="cb3-37"><a href="#cb3-37"></a>                        corners <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb3-38"><a href="#cb3-38"></a>                    <span class="cf">if</span> DIAGONALS[(dr,dc)] <span class="op">==</span> <span class="st">&quot;up-right&quot;</span> <span class="kw">and</span> <span class="kw">not</span> fence_needed[<span class="dv">0</span>] <span class="kw">and</span> <span class="kw">not</span> fence_needed[<span class="dv">3</span>]:</span>
<span id="cb3-39"><a href="#cb3-39"></a>                        corners <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb3-40"><a href="#cb3-40"></a>                    <span class="cf">if</span> DIAGONALS[(dr,dc)] <span class="op">==</span> <span class="st">&quot;down-left&quot;</span> <span class="kw">and</span> <span class="kw">not</span> fence_needed[<span class="dv">1</span>] <span class="kw">and</span> <span class="kw">not</span> fence_needed[<span class="dv">2</span>]:</span>
<span id="cb3-41"><a href="#cb3-41"></a>                        corners <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb3-42"><a href="#cb3-42"></a>                    <span class="cf">if</span> DIAGONALS[(dr,dc)] <span class="op">==</span> <span class="st">&quot;down-right&quot;</span> <span class="kw">and</span> <span class="kw">not</span> fence_needed[<span class="dv">3</span>] <span class="kw">and</span> <span class="kw">not</span> fence_needed[<span class="dv">2</span>]:</span>
<span id="cb3-43"><a href="#cb3-43"></a>                        corners <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb3-44"><a href="#cb3-44"></a></span>
<span id="cb3-45"><a href="#cb3-45"></a>        plot[<span class="st">&quot;corners&quot;</span>] <span class="op">=</span> corners</span>
<span id="cb3-46"><a href="#cb3-46"></a>        new_plots.append(plot)</span>
<span id="cb3-47"><a href="#cb3-47"></a>    <span class="cf">return</span> new_plots</span>
<span id="cb3-48"><a href="#cb3-48"></a></span>
<span id="cb3-49"><a href="#cb3-49"></a><span class="kw">def</span> count_corners(fence_needed):</span>
<span id="cb3-50"><a href="#cb3-50"></a>    count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb3-51"><a href="#cb3-51"></a>    <span class="cf">if</span> fence_needed[<span class="dv">0</span>] <span class="kw">and</span> fence_needed[<span class="dv">1</span>]:</span>
<span id="cb3-52"><a href="#cb3-52"></a>        count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb3-53"><a href="#cb3-53"></a>    <span class="cf">if</span> fence_needed[<span class="dv">1</span>] <span class="kw">and</span> fence_needed[<span class="dv">2</span>]:</span>
<span id="cb3-54"><a href="#cb3-54"></a>        count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb3-55"><a href="#cb3-55"></a>    <span class="cf">if</span> fence_needed[<span class="dv">2</span>] <span class="kw">and</span> fence_needed[<span class="dv">3</span>]:</span>
<span id="cb3-56"><a href="#cb3-56"></a>        count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb3-57"><a href="#cb3-57"></a>    <span class="cf">if</span> fence_needed[<span class="dv">3</span>] <span class="kw">and</span> fence_needed[<span class="dv">0</span>]:</span>
<span id="cb3-58"><a href="#cb3-58"></a>        count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb3-59"><a href="#cb3-59"></a>    </span>
<span id="cb3-60"><a href="#cb3-60"></a>    <span class="cf">return</span> count</span>
<span id="cb3-61"><a href="#cb3-61"></a></span>
<span id="cb3-62"><a href="#cb3-62"></a><span class="kw">def</span> get_cost(plots):</span>
<span id="cb3-63"><a href="#cb3-63"></a>    costs <span class="op">=</span> []</span>
<span id="cb3-64"><a href="#cb3-64"></a>    <span class="cf">for</span> plot <span class="kw">in</span> plots:</span>
<span id="cb3-65"><a href="#cb3-65"></a>        area <span class="op">=</span> <span class="bu">len</span>(plot[<span class="st">&quot;locations&quot;</span>])</span>
<span id="cb3-66"><a href="#cb3-66"></a>        sides <span class="op">=</span> plot[<span class="st">&quot;corners&quot;</span>]</span>
<span id="cb3-67"><a href="#cb3-67"></a>        costs.append(area <span class="op">*</span> sides)</span>
<span id="cb3-68"><a href="#cb3-68"></a>    </span>
<span id="cb3-69"><a href="#cb3-69"></a>    total_cost <span class="op">=</span> <span class="bu">sum</span>(costs)</span>
<span id="cb3-70"><a href="#cb3-70"></a></span>
<span id="cb3-71"><a href="#cb3-71"></a>    <span class="cf">return</span> total_cost</span>
<span id="cb3-72"><a href="#cb3-72"></a></span>
<span id="cb3-73"><a href="#cb3-73"></a><span class="kw">def</span> get_neighbors(garden, point, visited <span class="op">=</span> <span class="va">None</span>, current_plot <span class="op">=</span> <span class="va">None</span>, perimeter<span class="op">=</span><span class="dv">0</span>):</span>
<span id="cb3-74"><a href="#cb3-74"></a>    <span class="cf">if</span> visited <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb3-75"><a href="#cb3-75"></a>        visited <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb3-76"><a href="#cb3-76"></a></span>
<span id="cb3-77"><a href="#cb3-77"></a>    <span class="cf">if</span> current_plot <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb3-78"><a href="#cb3-78"></a>        current_plot <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb3-79"><a href="#cb3-79"></a></span>
<span id="cb3-80"><a href="#cb3-80"></a>    <span class="cf">if</span> point <span class="kw">in</span> visited:</span>
<span id="cb3-81"><a href="#cb3-81"></a>        <span class="cf">return</span> current_plot, perimeter</span>
<span id="cb3-82"><a href="#cb3-82"></a></span>
<span id="cb3-83"><a href="#cb3-83"></a>    visited.add(point)</span>
<span id="cb3-84"><a href="#cb3-84"></a>    current_plot.add(point)</span>
<span id="cb3-85"><a href="#cb3-85"></a></span>
<span id="cb3-86"><a href="#cb3-86"></a>    <span class="cf">for</span> dr,dc <span class="kw">in</span> DIRECTIONS:</span>
<span id="cb3-87"><a href="#cb3-87"></a>        nr, nc <span class="op">=</span> point[<span class="dv">0</span>] <span class="op">+</span> dr, point[<span class="dv">1</span>] <span class="op">+</span> dc</span>
<span id="cb3-88"><a href="#cb3-88"></a>        <span class="cf">if</span> <span class="dv">0</span> <span class="op">&lt;=</span> nr <span class="op">&lt;</span> <span class="bu">len</span>(garden) <span class="kw">and</span> <span class="dv">0</span> <span class="op">&lt;=</span> nc <span class="op">&lt;</span> <span class="bu">len</span>(garden[<span class="dv">0</span>]):</span>
<span id="cb3-89"><a href="#cb3-89"></a>            <span class="cf">if</span> garden[point[<span class="dv">0</span>]][point[<span class="dv">1</span>]] <span class="op">==</span> garden[nr][nc]:</span>
<span id="cb3-90"><a href="#cb3-90"></a>                _, perimeter <span class="op">=</span> get_neighbors(garden, (nr,nc), visited, current_plot, perimeter<span class="op">=</span>perimeter)</span>
<span id="cb3-91"><a href="#cb3-91"></a>            <span class="co"># If they dont match, this position is a boundary</span></span>
<span id="cb3-92"><a href="#cb3-92"></a>            <span class="cf">else</span>:</span>
<span id="cb3-93"><a href="#cb3-93"></a>                perimeter <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb3-94"><a href="#cb3-94"></a>        <span class="cf">else</span>:</span>
<span id="cb3-95"><a href="#cb3-95"></a>            perimeter <span class="op">+=</span><span class="dv">1</span></span>
<span id="cb3-96"><a href="#cb3-96"></a>    </span>
<span id="cb3-97"><a href="#cb3-97"></a>    <span class="cf">return</span> current_plot, perimeter</span>
<span id="cb3-98"><a href="#cb3-98"></a></span>
<span id="cb3-99"><a href="#cb3-99"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:</span>
<span id="cb3-100"><a href="#cb3-100"></a>    <span class="cf">with</span> <span class="bu">open</span>(<span class="st">&quot;day12.txt&quot;</span>) <span class="im">as</span> f:</span>
<span id="cb3-101"><a href="#cb3-101"></a>        garden <span class="op">=</span> f.read().split(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb3-102"><a href="#cb3-102"></a>    </span>
<span id="cb3-103"><a href="#cb3-103"></a>    nrows <span class="op">=</span> <span class="bu">len</span>(garden)</span>
<span id="cb3-104"><a href="#cb3-104"></a>    ncols <span class="op">=</span> <span class="bu">len</span>(garden[<span class="dv">0</span>])</span>
<span id="cb3-105"><a href="#cb3-105"></a></span>
<span id="cb3-106"><a href="#cb3-106"></a>    plots <span class="op">=</span> [] <span class="co"># values are (letter, points included in the plot), area is the length of the set</span></span>
<span id="cb3-107"><a href="#cb3-107"></a>    visited <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb3-108"><a href="#cb3-108"></a>    <span class="cf">for</span> row <span class="kw">in</span> <span class="bu">range</span>(nrows):</span>
<span id="cb3-109"><a href="#cb3-109"></a>        <span class="cf">for</span> col <span class="kw">in</span> <span class="bu">range</span>(ncols):</span>
<span id="cb3-110"><a href="#cb3-110"></a>            <span class="cf">if</span> (row,col) <span class="kw">not</span> <span class="kw">in</span> visited:</span>
<span id="cb3-111"><a href="#cb3-111"></a>                curr_letter <span class="op">=</span> garden[row][col]</span>
<span id="cb3-112"><a href="#cb3-112"></a>                places, perimeter <span class="op">=</span> get_neighbors(garden, (row,col), visited<span class="op">=</span>visited)</span>
<span id="cb3-113"><a href="#cb3-113"></a>                plots.append({<span class="st">&quot;letter&quot;</span>:curr_letter,<span class="st">&quot;locations&quot;</span>:places, <span class="st">&quot;perimeter&quot;</span>:perimeter})</span>
<span id="cb3-114"><a href="#cb3-114"></a></span>
<span id="cb3-115"><a href="#cb3-115"></a>    plots_with_corners <span class="op">=</span> get_corners(plots)</span>
<span id="cb3-116"><a href="#cb3-116"></a>    <span class="bu">print</span>(get_cost(plots_with_corners))</span></code></pre></div>
<h3 id="chatgpts-improved-code-1">ChatGPT&#x2019;s Improved Code</h3>
<div class="sourceCode" id="cb4"><pre
class="sourceCode numberSource python numberLines"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a><span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb4-2"><a href="#cb4-2"></a></span>
<span id="cb4-3"><a href="#cb4-3"></a>DIRECTIONS <span class="op">=</span> [</span>
<span id="cb4-4"><a href="#cb4-4"></a>    (<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>),  <span class="co"># up</span></span>
<span id="cb4-5"><a href="#cb4-5"></a>    (<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>),  <span class="co"># left</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>    (<span class="dv">1</span>, <span class="dv">0</span>),   <span class="co"># down</span></span>
<span id="cb4-7"><a href="#cb4-7"></a>    (<span class="dv">0</span>, <span class="dv">1</span>),   <span class="co"># right</span></span>
<span id="cb4-8"><a href="#cb4-8"></a>]</span>
<span id="cb4-9"><a href="#cb4-9"></a></span>
<span id="cb4-10"><a href="#cb4-10"></a>DIAGONALS <span class="op">=</span> [</span>
<span id="cb4-11"><a href="#cb4-11"></a>    (<span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>),  <span class="co"># up-left</span></span>
<span id="cb4-12"><a href="#cb4-12"></a>    (<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>),   <span class="co"># up-right</span></span>
<span id="cb4-13"><a href="#cb4-13"></a>    (<span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>),   <span class="co"># down-left</span></span>
<span id="cb4-14"><a href="#cb4-14"></a>    (<span class="dv">1</span>, <span class="dv">1</span>),    <span class="co"># down-right</span></span>
<span id="cb4-15"><a href="#cb4-15"></a>]</span>
<span id="cb4-16"><a href="#cb4-16"></a></span>
<span id="cb4-17"><a href="#cb4-17"></a></span>
<span id="cb4-18"><a href="#cb4-18"></a><span class="kw">def</span> is_in_bounds(garden, r, c):</span>
<span id="cb4-19"><a href="#cb4-19"></a>    <span class="cf">return</span> <span class="dv">0</span> <span class="op">&lt;=</span> r <span class="op">&lt;</span> <span class="bu">len</span>(garden) <span class="kw">and</span> <span class="dv">0</span> <span class="op">&lt;=</span> c <span class="op">&lt;</span> <span class="bu">len</span>(garden[<span class="dv">0</span>])</span>
<span id="cb4-20"><a href="#cb4-20"></a></span>
<span id="cb4-21"><a href="#cb4-21"></a></span>
<span id="cb4-22"><a href="#cb4-22"></a><span class="kw">def</span> get_cost(plots):</span>
<span id="cb4-23"><a href="#cb4-23"></a>    <span class="cf">return</span> <span class="bu">sum</span>(<span class="bu">len</span>(plot[<span class="st">&quot;locations&quot;</span>]) <span class="op">*</span> plot[<span class="st">&quot;corners&quot;</span>] <span class="cf">for</span> plot <span class="kw">in</span> plots)</span>
<span id="cb4-24"><a href="#cb4-24"></a></span>
<span id="cb4-25"><a href="#cb4-25"></a></span>
<span id="cb4-26"><a href="#cb4-26"></a><span class="kw">def</span> get_neighbors(garden, start, visited):</span>
<span id="cb4-27"><a href="#cb4-27"></a>    queue <span class="op">=</span> deque([start])</span>
<span id="cb4-28"><a href="#cb4-28"></a>    current_plot <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb4-29"><a href="#cb4-29"></a>    visited.add(start)</span>
<span id="cb4-30"><a href="#cb4-30"></a>    letter <span class="op">=</span> garden[start[<span class="dv">0</span>]][start[<span class="dv">1</span>]]</span>
<span id="cb4-31"><a href="#cb4-31"></a></span>
<span id="cb4-32"><a href="#cb4-32"></a>    <span class="cf">while</span> queue:</span>
<span id="cb4-33"><a href="#cb4-33"></a>        r, c <span class="op">=</span> queue.popleft()</span>
<span id="cb4-34"><a href="#cb4-34"></a>        current_plot.add((r, c))</span>
<span id="cb4-35"><a href="#cb4-35"></a></span>
<span id="cb4-36"><a href="#cb4-36"></a>        <span class="cf">for</span> dr, dc <span class="kw">in</span> DIRECTIONS:</span>
<span id="cb4-37"><a href="#cb4-37"></a>            nr, nc <span class="op">=</span> r <span class="op">+</span> dr, c <span class="op">+</span> dc</span>
<span id="cb4-38"><a href="#cb4-38"></a>            <span class="cf">if</span> is_in_bounds(garden, nr, nc) <span class="kw">and</span> garden[nr][nc] <span class="op">==</span> letter <span class="kw">and</span> (nr, nc) <span class="kw">not</span> <span class="kw">in</span> visited:</span>
<span id="cb4-39"><a href="#cb4-39"></a>                queue.append((nr, nc))</span>
<span id="cb4-40"><a href="#cb4-40"></a>                visited.add((nr, nc))</span>
<span id="cb4-41"><a href="#cb4-41"></a></span>
<span id="cb4-42"><a href="#cb4-42"></a>    <span class="cf">return</span> current_plot</span>
<span id="cb4-43"><a href="#cb4-43"></a></span>
<span id="cb4-44"><a href="#cb4-44"></a></span>
<span id="cb4-45"><a href="#cb4-45"></a><span class="kw">def</span> count_corners(locations):</span>
<span id="cb4-46"><a href="#cb4-46"></a>    corners <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb4-47"><a href="#cb4-47"></a>    location_set <span class="op">=</span> <span class="bu">set</span>(locations)</span>
<span id="cb4-48"><a href="#cb4-48"></a></span>
<span id="cb4-49"><a href="#cb4-49"></a>    <span class="cf">for</span> r, c <span class="kw">in</span> locations:</span>
<span id="cb4-50"><a href="#cb4-50"></a>        fence_needed <span class="op">=</span> [</span>
<span id="cb4-51"><a href="#cb4-51"></a>            (r <span class="op">+</span> dr, c <span class="op">+</span> dc) <span class="kw">not</span> <span class="kw">in</span> location_set</span>
<span id="cb4-52"><a href="#cb4-52"></a>            <span class="cf">for</span> dr, dc <span class="kw">in</span> DIRECTIONS</span>
<span id="cb4-53"><a href="#cb4-53"></a>        ]</span>
<span id="cb4-54"><a href="#cb4-54"></a></span>
<span id="cb4-55"><a href="#cb4-55"></a>        <span class="co"># Count corners formed by two fences meeting</span></span>
<span id="cb4-56"><a href="#cb4-56"></a>        <span class="cf">for</span> (idx1, idx2) <span class="kw">in</span> [(<span class="dv">0</span>, <span class="dv">1</span>), (<span class="dv">1</span>, <span class="dv">2</span>), (<span class="dv">2</span>, <span class="dv">3</span>), (<span class="dv">3</span>, <span class="dv">0</span>)]:</span>
<span id="cb4-57"><a href="#cb4-57"></a>            <span class="cf">if</span> fence_needed[idx1] <span class="kw">and</span> fence_needed[idx2]:</span>
<span id="cb4-58"><a href="#cb4-58"></a>                corners <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb4-59"><a href="#cb4-59"></a></span>
<span id="cb4-60"><a href="#cb4-60"></a>        <span class="co"># Check diagonal fences</span></span>
<span id="cb4-61"><a href="#cb4-61"></a>        <span class="cf">for</span> (dr, dc), (idx1, idx2) <span class="kw">in</span> <span class="bu">zip</span>(DIAGONALS, [(<span class="dv">0</span>, <span class="dv">1</span>), (<span class="dv">0</span>, <span class="dv">3</span>), (<span class="dv">2</span>, <span class="dv">1</span>), (<span class="dv">2</span>, <span class="dv">3</span>)]):</span>
<span id="cb4-62"><a href="#cb4-62"></a>            <span class="cf">if</span> (r <span class="op">+</span> dr, c <span class="op">+</span> dc) <span class="kw">not</span> <span class="kw">in</span> location_set <span class="kw">and</span> <span class="kw">not</span> (fence_needed[idx1] <span class="kw">or</span> fence_needed[idx2]):</span>
<span id="cb4-63"><a href="#cb4-63"></a>                corners <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb4-64"><a href="#cb4-64"></a></span>
<span id="cb4-65"><a href="#cb4-65"></a>    <span class="cf">return</span> corners</span>
<span id="cb4-66"><a href="#cb4-66"></a></span>
<span id="cb4-67"><a href="#cb4-67"></a></span>
<span id="cb4-68"><a href="#cb4-68"></a><span class="kw">def</span> get_corners(plots):</span>
<span id="cb4-69"><a href="#cb4-69"></a>    <span class="cf">for</span> plot <span class="kw">in</span> plots:</span>
<span id="cb4-70"><a href="#cb4-70"></a>        plot[<span class="st">&quot;corners&quot;</span>] <span class="op">=</span> count_corners(plot[<span class="st">&quot;locations&quot;</span>])</span>
<span id="cb4-71"><a href="#cb4-71"></a>    <span class="cf">return</span> plots</span>
<span id="cb4-72"><a href="#cb4-72"></a></span>
<span id="cb4-73"><a href="#cb4-73"></a></span>
<span id="cb4-74"><a href="#cb4-74"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:</span>
<span id="cb4-75"><a href="#cb4-75"></a>    <span class="cf">try</span>:</span>
<span id="cb4-76"><a href="#cb4-76"></a>        <span class="cf">with</span> <span class="bu">open</span>(<span class="st">&quot;day12.txt&quot;</span>) <span class="im">as</span> f:</span>
<span id="cb4-77"><a href="#cb4-77"></a>            garden <span class="op">=</span> f.read().strip().split(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb4-78"><a href="#cb4-78"></a>    <span class="cf">except</span> <span class="pp">FileNotFoundError</span>:</span>
<span id="cb4-79"><a href="#cb4-79"></a>        <span class="bu">print</span>(<span class="st">&quot;Input file &#39;day12.txt&#39; not found.&quot;</span>)</span>
<span id="cb4-80"><a href="#cb4-80"></a>        exit(<span class="dv">1</span>)</span>
<span id="cb4-81"><a href="#cb4-81"></a></span>
<span id="cb4-82"><a href="#cb4-82"></a>    nrows, ncols <span class="op">=</span> <span class="bu">len</span>(garden), <span class="bu">len</span>(garden[<span class="dv">0</span>])</span>
<span id="cb4-83"><a href="#cb4-83"></a>    visited <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb4-84"><a href="#cb4-84"></a>    plots <span class="op">=</span> []</span>
<span id="cb4-85"><a href="#cb4-85"></a></span>
<span id="cb4-86"><a href="#cb4-86"></a>    <span class="cf">for</span> row <span class="kw">in</span> <span class="bu">range</span>(nrows):</span>
<span id="cb4-87"><a href="#cb4-87"></a>        <span class="cf">for</span> col <span class="kw">in</span> <span class="bu">range</span>(ncols):</span>
<span id="cb4-88"><a href="#cb4-88"></a>            <span class="cf">if</span> (row, col) <span class="kw">not</span> <span class="kw">in</span> visited:</span>
<span id="cb4-89"><a href="#cb4-89"></a>                locations <span class="op">=</span> get_neighbors(garden, (row, col), visited)</span>
<span id="cb4-90"><a href="#cb4-90"></a>                plots.append({</span>
<span id="cb4-91"><a href="#cb4-91"></a>                    <span class="st">&quot;letter&quot;</span>: garden[row][col],</span>
<span id="cb4-92"><a href="#cb4-92"></a>                    <span class="st">&quot;locations&quot;</span>: locations</span>
<span id="cb4-93"><a href="#cb4-93"></a>                })</span>
<span id="cb4-94"><a href="#cb4-94"></a></span>
<span id="cb4-95"><a href="#cb4-95"></a>    plots_with_corners <span class="op">=</span> get_corners(plots)</span>
<span id="cb4-96"><a href="#cb4-96"></a>    <span class="bu">print</span>(get_cost(plots_with_corners))</span></code></pre></div>
<h2 id="what-i-learned">What I Learned</h2>
<h3 id="using-bfs-instead-of-recursion">Using BFS Instead of
Recursion</h3>
<ul>
<li>For part 1, Chat GPT used a BFS approach rather than the recursive
function, which can save time and memory usage.</li>
<li>The BFS can be implemented with a simple queue, and processes the
letters for each plot iteratively.</li>
</ul>
<h3 id="while-queue"><code>while queue</code></h3>
<ul>
<li>In Python, this statement is enough to continue the
<code>while</code> loop (no need for
<code>while len(queue) &gt; 0</code>)</li>
</ul>
<h3 id="zip"><code>zip()</code></h3>
<ul>
<li>My code for Part 2 is admittedly a mess, but I was a few days behind
in Advent of Code and just wanted to get through it.</li>
<li>ChatGPT&#x2019;s use of <code>zip()</code> is what I wanted but couldn&#x2019;t
think of when I was writing the logic for the diagonal corners&#x2026; it felt
like there should be an easier way but I couldn&#x2019;t think of it, and just
wanted to see if this logic would work.</li>
<li><code>zip()</code> takes any number of iterators as an argument and
then returns the pairs of each iterator at each position. In this
example, the first list was <code>DIAGONALS</code> and the second was
the tuple of indices of <code>fence_needed</code> to consider for that
diagonal.</li>
<li>A similar concept is used in the <code>for</code> loop to count the
corners, rather than an individual <code>if</code> statement for every
pair.</li>
</ul>
            <hr />
            <p>Callista Krebs, 2024</p>
        </article>
    </main>
    <style>
        html { -webkit-text-size-adjust: 100%; }
        pre > code.sourceCode { white-space: pre; position: relative; }
        pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
        pre > code.sourceCode > span:empty { height: 1.2em; }
        .sourceCode { overflow: visible; }
        code.sourceCode > span { color: inherit; text-decoration: inherit; }
        div.sourceCode { margin: 1em 0; }
        pre.sourceCode { margin: 0; }
        @media screen {
        div.sourceCode { overflow: auto; }
        }
        @media print {
        pre > code.sourceCode { white-space: pre-wrap; }
        pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
        }
        pre.numberSource code
          { counter-reset: source-line 0; }
        pre.numberSource code > span
          { position: relative; left: -4em; counter-increment: source-line; }
        pre.numberSource code > span > a:first-child::before
          { content: counter(source-line);
            position: relative; left: -1em; text-align: right; vertical-align: baseline;
            border: none; display: inline-block;
            -webkit-touch-callout: none; -webkit-user-select: none;
            -khtml-user-select: none; -moz-user-select: none;
            -ms-user-select: none; user-select: none;
            padding: 0 4px; width: 4em;
            color: #aaaaaa;
          }
        pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
        div.sourceCode
          {   }
        @media screen {
        pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
        }
        code span.al { color: #ff0000; font-weight: bold; } /* Alert */
        code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
        code span.at { color: #7d9029; } /* Attribute */
        code span.bn { color: #40a070; } /* BaseN */
        code span.bu { color: #008000; } /* BuiltIn */
        code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
        code span.ch { color: #4070a0; } /* Char */
        code span.cn { color: #880000; } /* Constant */
        code span.co { color: #60a0b0; font-style: italic; } /* Comment */
        code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
        code span.do { color: #ba2121; font-style: italic; } /* Documentation */
        code span.dt { color: #902000; } /* DataType */
        code span.dv { color: #40a070; } /* DecVal */
        code span.er { color: #ff0000; font-weight: bold; } /* Error */
        code span.ex { } /* Extension */
        code span.fl { color: #40a070; } /* Float */
        code span.fu { color: #06287e; } /* Function */
        code span.im { color: #008000; font-weight: bold; } /* Import */
        code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
        code span.kw { color: #007020; font-weight: bold; } /* Keyword */
        code span.op { color: #666666; } /* Operator */
        code span.ot { color: #007020; } /* Other */
        code span.pp { color: #bc7a00; } /* Preprocessor */
        code span.sc { color: #4070a0; } /* SpecialChar */
        code span.ss { color: #bb6688; } /* SpecialString */
        code span.st { color: #4070a0; } /* String */
        code span.va { color: #19177c; } /* Variable */
        code span.vs { color: #4070a0; } /* VerbatimString */
        code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    </style>
</body>
</html>